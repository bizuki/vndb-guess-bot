mod fields;

use darling::{ast::Data, FromDeriveInput};
use proc_macro::TokenStream;
use proc_macro_error::{abort, proc_macro_error};
use quote::{format_ident, quote};
use syn::{parse_macro_input, DeriveInput};

use crate::fields::FieldInput;

#[derive(Debug, FromDeriveInput)]
#[darling(attributes(vndb_field), supports(struct_any))]
struct MacroInput {
    ident: syn::Ident,
    data: Data<(), FieldInput>,
}

#[proc_macro_derive(VndbFieldsEnum, attributes(vndb_field))]
#[proc_macro_error]
pub fn derive_vndb_fields_enum(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);

    let MacroInput { ident: struct_ident, data }
        = FromDeriveInput::from_derive_input(&input).expect("can't parse attributes");

    // Ensure this is a struct with named fields
    let named_fields: Vec<FieldInput> = match data {
        Data::Struct(s) => {
            s.fields.into_iter()
                .map(|field| 
                    if field.ident.is_none() {
                        abort!(
                            field.ident,
                            "#[derive(VndbFieldsEnum)] can process named fields"
                        );
                    } else {
                        field
                    }
                )
                .collect()
        }
        _ => abort!(
            struct_ident,
            "#[derive(VndbFieldsEnum)] can only be used on structs"
        ),
    };

    // Generated enum name: <StructName>Fields
    let enum_ident = format_ident!("{}Fields", struct_ident);
    
    let field_infos = named_fields.iter()
        .filter_map(fields::get_field_info)
        .collect::<Vec<_>>();

    let variant_idents: Vec<_> = field_infos.iter()
        .map(|info| {
            let variant_ident = info.name.clone();
            match info.referenced_type.clone() {
                Some(referenced_type) => quote! {
                    #variant_ident(Vec<#referenced_type>)
                },
                None => quote! {
                    #variant_ident
                },
            }
        })
        .collect();

    let serialization_variants: Vec<_> = field_infos.into_iter()
        .map(|info| {
            let variant_ident = info.name;
            let path = info.path;

            match &info.referenced_type {
                Some(_) => quote! {
                    Self::#variant_ident(items) => {
                        let items = items.iter()
                            .map(|item| item.to_string())
                            .map(std::borrow::Cow::from)
                            .reduce(|mut acc, item| {
                                acc.to_mut().push(',');
                                acc.to_mut().push_str(&item);
                                acc
                            })
                            .unwrap_or_default();

                        format!("{}{{{items}}}", #path)
                    }
                },
                None => quote! {
                    Self::#variant_ident => #path.to_string()
                },
            }
        })
        .collect();

    let expanded = quote! {
        /// Auto-generated by `#[derive(FieldsEnum)]`.
        #[allow(dead_code)]
        #[derive(Debug, Clone)]
        pub enum #enum_ident {
            #( #variant_idents, )*
        }

        impl serde::Serialize for #enum_ident {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer 
            {
                serializer.serialize_str(&self.to_string())
            }
        }

        impl ToString for #enum_ident {
            fn to_string(&self) -> String {
                match self {
                    #( #serialization_variants, )*
                }
            }
        }
    };

    TokenStream::from(expanded)
}
